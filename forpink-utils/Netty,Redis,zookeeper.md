##### Netty
Netty是一个基于NIO的客户端/服务器编程的通信协议框架.可以开发高可用, 高并发,高可靠性的网络服务程序和客户端程序
    NIO是一个非阻塞输入输出, 即非阻塞IO
    
+ 优点:
    1, API简单, 开发门槛低
    2, 功能强大, 预置了多重编解码功能, 支持多种主流协议
    3, 定制能力强,   可以通过ChannelHandle对通信框架进行灵活扩展
    4, 性能高, 与其他NIO比较, Netty综合性高最优
    5, 成熟,稳定, Netty修复了JDK NIO中的bug, 业务开发人员不用为NIO的bug而烦恼
    6, 社区活跃, 版本更新周期短, 发现的bug能及时修复
    
#### Redis
Redis是一款应用广泛的,高效的开源缓存,数据存储在内存中, 读取数据非常快.
+ 存储类型, 使用键值对形式存储数据, 类似于map映射, 其中key值只能是String类型,value值, 可以是,String、map映射类型、list列表类型、set类型、sortedset有序集合类型

+ 应用场景: 
    1, 缓存(数据查询、短连接、新闻内容、商品内容)等
    2, 分布式会话session
    3, 聊天室的在线好友列表
    4, 任务队列(秒杀,抢购, 12306)
    5, 应用排行榜
    6, 访问统计
    7, 数据过期处理
+ 优点:
    1, 速度快
    2,丰富的数据结构
    3,单线程
    4,分布式锁
    5,可持久化
    6,支持订阅/发布
    7,支持lua脚本
    8, 支持原子操作和事务
    9,支持主从复制和高可用集群
    10, 支持管道: 管道特点, 在批量执行命令的应用场景中, 可以减少网络传输的开销, 提高性能
    
### Zookeeper
zookeeper是分布式协调工具

+ 优势
    核心就是实现了分布式数据的一致性
    
    
### IO原理
IO就是输入/输出操作, READ系统是将内核缓冲区数据读入用户进程缓冲区,WRITE系统是将用户进程缓冲区写入内核缓冲区

+ 4中IO操作:
    1, 同步阻塞IO
        用户线程程序发起read请求, 内核缓冲区等待准备数据, 将数据复制到用户缓冲区,最后返回调用, 整个过程用户线程阻塞等待完成
    2, 同步非阻塞IO
        用户线程不断发起read请求, 内核系统返回标识给用户, 直到数据准备完毕, 开始复制(用户进程阻塞), 复制完成返回调用,线程完成
    3, IO多路复用
        引入一个select类管理, 用户程序进行select注册, select查询内核缓冲数据是否准备完毕, 然后返回可读可连接给用户进程, 用户线程发送read请求, 将数据从内核缓冲区读入用户进程缓冲区, 最后返回调用
    4, 异步IO
        用户线程程序发起read请求, 然后不挂起线程, 直至系统内核将内核缓冲区数据复制到用户缓冲区, 然后发送通知或者回调用户线程程序
    
+ 高并发IO的底层配置, 即单个进程可以同时打开的文件句柄数(linux默认是1024, 通过ulimit -n查看, 一般硬件极限是100w)   
    
    
### 第三章:java NIO

#### 1, 简介:

java NIO: jdk1.4之后引进的新的异步IO库, 称为 NEW IO, 他的目标是为了支持非阻塞IO, 所以很多人也叫非阻塞io
    它三部分组成: 
        1, Channel(通道)
            在OIO中, 同一个网络连接会关联到两个流: 一个输入流(Input Stream), 另一个输出流(Output Stream), 通过这两个流不断的进行输入和输出
    在NIO中, 同一个网络连接使用一个通道表示, 所有的NIO的io操作都是从通道开始, 一个通道类似于OIO两个流的集合体, 既可以从通道读取, 也可以像通道中写入
        2, Buffer(缓冲区)
            他是一个IO事件的查询器, 通过选择器, 一个线程可以查询多个通道的IO事件的就状态
    使用selector选择器的优点就是系统开销小, 系统不必为每一个网络连接(文件描述符)创建进程/线程从而减小系统的开销
        3, selector(选择器)
            他是一个IO事件的查询器, 通过选择器, 一个线程可以查询多个通道的IO事件的就状态
    使用selector选择器的优点就是系统开销小, 系统不必为每一个网络连接(文件描述符)创建进程/线程从而减小系统的开销

+ 1 java NIO和OIO的对比: 
    - 1 OIO是面向流的(Stream Oriented), NIO是面向缓冲区的(Buffer Oriented)
    - 2 OIO是阻塞的, NIO是非阻塞的
    - 3 OIO没有选择器概念, 而NIO有选择器的概念
    
#### 4 Buffer   
+ capacity  容量
+ limit     上限 当前数据量
+ position  位置  缓冲区中下一个要被读/写的位置
+ mark      标记

#### 5 channel
#### 6 selector

### 第四章: REACTOR反应器
什么是reactor反应模式:
    由Reactor反应器线程和Handlers处理器两大角色组成:
+ Reactor反应器线程职责是: 负责响应IO组件, 分发到Handler处理器
+ Handlers处理器的职责是: 非阻塞的执行业务处理逻辑

+ 

### 第5章 并发基础中的Future异步回调模式

#### 1. JOIN异步阻塞: 阻塞当前线程,直到需要合并的目标线程执行完成
    join方法的应用场景：A线程调用B线程的join方法，等待B线程执行完成；在B线程没有完成前，A线程阻塞。

强调一下容易混淆的几点：
（1）join是实例方法，不是静态方法，需要使用线程对象去调用，如thread.join()。
（2）join调用时，不是线程所指向的目标线程阻塞，而是当前线程阻塞。
（3）只有等到当前线程所指向的线程执行完成，或者超时，当前线程才能重新恢复执行。
join有一个问题：被合并的线程没有返回值。例如，在烧水的实例中，如果烧水线程的执行结束，main线程是无法知道结果的。同样，清洗线程的执行结果，main线程也是无法知道的。形象地说，join线程合并就是一像一个闷葫芦。只能发起合并线程，不能取到执行结果。
如果需要获得异步线程的执行结果，怎么办呢？可以使用Java的FutureTask系列类。
    
#### 2. Callable接口
    Runnable接口没有返回值, Callable接口有返回值, run方法对应call方法, Callable是泛型接口, 只有唯一的抽象发方法call(), Runnable可以直接赋值给Thread的目标, 运行, Callable需要通过FutureTask类
    
    
#### 3. FutureTask类
    FutureTask实际是Callable的二次封装, 简介继承Runnable接口, 所以可以作为Thread的target执行
    在java语言中, 将FutureTask的一系列操作抽象出来作为一个重要的接口---future接口, 当然FutureTask也实现了该接口

#### 4. Future接口
    Future接口不复杂，主要是对并发任务的执行及获取其结果的一些操作。主要提供了3大功能
（1）判断并发任务是否执行完成。
（2）获取并发的任务完成后的结果。
（3）取消并发执行中的任务。
关于Future接口的方法，详细说明如下：
V  get()：获取并发任务执行的结果。注意，这个方法是阻塞性的。如果并发任务没有执行完成，调用此方法的线程会一直阻塞，直到并发任务执行完成。
V get(Long timeout，TimeUnit unit)：获取并发任务执行的结果。也是阻塞性的，但是会有阻塞的时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。
boolean isDone()：获取并发任务的执行状态。如果任务执行结束，则返回true。
boolean isCancelled()：获取并发任务的取消状态。如果任务完成前被取消，则返回true。
boolean cancel(booleanmayInterruptRunning)：取消并发任务的执行。
#### 5 FutureTask烧水实例

#### 6 Guava
1) 引入了一个新的接口ListenableFuture, 继承了JAVAde Future接口, 是的java的Future异步任务在Guava中能被监控和获得非阻塞异步执行的结果
2) 引入了一个新的接口FutureCallback, 这个是一个独立的接口, 该接口的目的是异步任务执行完成后,根据异步结果完成不同的回调处理, 并且可以处理异常结果
    

### 
ZooKeeper（本书也简称ZK）是Hadoop的正式子项目，它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、分布式同步、组服务等。

ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。

ZooKeeper在实际生产环境中应用非常广泛，例如SOA的服务监控系统、Hadoop、Spark的分布式调度系统。  
    
    
    
    
http:
    multipart.maxFileSize=20Mb
#所有上传文件最大大小
http:
    multipart:
        maxRequestSize: 1000Mb  
    
    
    
    
    
### 11 Redis
Redis是一个分布式缓存
安装后配置的方法:
+ 1 复制redis.window.conf redis.conf redis.conf里面默认配置
+ 2 通过命令配置, config 
    
#### 11.1 客户端命令
+ 1 连接命令: redis-cli -h 127.0.0.1 -p 6379 -a '密码'
+ 2 set命令set foo bar: 根据key设置value
+ 3 get命令get foo: 根据key,获取value, key不存在返回空
+ 4 keys命令：查找所有符合给定模式（Pattern）的Key。?匹配一个字符*匹配任意个字符[-]匹配区间内的任一字符
+ 5 exists: 判断一个key是否存在, 存在返回1,否则返回0
+ 6 expire命令：为指定的Key设置过期时间，以秒为单位    
+ 7 ttl命名：返回指定Key的剩余生存时间（ttl,time to live），以秒为单位
+ 9 type命令：返回Key所存储的Value值的类型。最简单的类型为string类型。Redis中有5种数据类型：String（字符串类型）、Hash（哈希类型）、List（列表类型）、Set（集合类型）、Zset（有序集合类型），     
+ 10 del命令：删除Key，可以删除一个或多个Key
+ 11 ping命令：检查客户端是否连接成功，如果连接成功，则返回pong  
        
#### 11.2 命名规范
    使用:分隔方便分层展示, 方便删除和维护
#### 11.3 数据类型
String 字符串类型, Hash 哈希类型, List 列表, set集合, zset有序集合

#### 监听的两种方式
使用标准的Watcher, 但是只能监听一次
使用缓存机制的监听包括: Node Cache, Path Cache, Tree Cache
+ （1）Node Cache节点缓存可用于ZNode节点的监听；

+ （2）Path Cache子节点缓存可用于ZNode的子节点的监听；

+ （3）Tree Cache树缓存是Path Cache的增强，不光能监听子节点，还能监听ZNode节点自身。        
        

1.ZooKeeper的每一个节点都是一个天然的顺序发号器
  在每一个节点下面创建临时顺序节点（EPHEMERAL_SEQUENTIAL）类型，新的子节点后面会加上一个顺序编号。这个顺序编号是在上一个生成的顺序编号加1        

2.ZooKeeper节点的递增有序性可以确保锁的公平
  一个ZooKeeper分布式锁，首先需要创建一个父节点，尽量是持久节点（PERSISTENT类型），然后每个要获得锁的线程都在这个节点下创建个临时顺序节点。由于Zk节点是按照创建的顺序依次递增的，为了确保公平，可以简单地规定，编号最小的那个节点表示获得了锁。因此，每个线程在尝试占用锁之前，首先判断自己的排号是不是当前最小的，如果是，则获取锁。  
        
3.ZooKeeper的节点监听机制可以保障占有锁的传递有序而且高效

每个线程抢占锁之前，先抢号创建自己的ZNode。同样，释放锁的时候，就需要删除抢号的ZNode。在抢号成功之后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个ZNode的通知即可。当前一个ZNode被删除的时候，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后传递 

4.ZooKeeper的节点监听机制能避免羊群效应
        
    
分布式锁算法, 流程大致如下:
1, 一把锁就是一个节点
2, 抢占锁的客户端就是节点的子节点
3, 判断是否占有锁
4, 获取到前一个节点的变更通知
5, 获取锁后开始处理业务流程, 完成后删除自己对应的子节点, 完成释放锁工作, 以便通知下一个
使用ZooKeeper实现分布式锁的算法，流程大致如下：

（1）一把锁，使用一个ZNode节点表示，如果锁对应的ZNode节点不存在，那么先创建ZNode节点。这里假设为“/test/lock”，代表了一把需要创建的分布式锁。

（2）抢占锁的所有客户端，使用锁的ZNode节点的子节点列表来表示；如果某个客户端需要占用锁，则在“/test/lock”下创建一个临时有序的子节点。

这里，所有子节点尽量共用一个有意义的子节点前缀。

如果子节点前缀为“/test/lock/seq-”，则第一个客户端对应的子节点为“/test/lock/seq-000000000”，第二个为“/test/lock/seq-000000001”，以此类推。

如果子节点前缀为“/test/lock/”，则第一个客户端对应的子节点为“/test/lock/000000000”，第二个为“/test/lock/000000001”，以此类推，也非常直观。

（3）如果判定客户端是否占有锁呢？很简单，客户端创建子节点后，需要进行判断：自己创建的子节点是否为当前子节点列表中序号最小的子节点。如果是，则认为加锁成功；如果不是，则监听前一个ZNode子节点的变更消息，等待前一个节点释放锁。

（4）一旦队列中后面的节点获得前一个子节点的变更通知，则开始进行判断，判断自己是否为当前子节点列表中序号最小的子节点，如果是，则认为加锁成功；如果不是，则持续监听，一直到获得锁。

（5）获取锁后，开始处理业务流程。在完成业务流程后，删除自己对应的子节点，完成释放锁的工作，以便后面的节点能捕获到节点的变更通知，获得分布式锁     
        
        
最后，总结一下ZooKeeper分布式锁：
（1）优点：ZooKeeper分布式锁（如InterProcessMutex），能有效地解决分布式问题，不可重入问题，使用起来也较为简单。
（2）缺点：ZooKeeper实现的分布式锁，性能并不太高。为什么呢？因为每次在创建锁和释放锁的过程中，都要动态创建、销毁暂时节点来实现锁功能。大家知道，Zk中创建和删除节点只能通过Leader（主）服务器来执行，然后Leader服务器还需要将数据同步到所有的Follower（从）服务器上，这样频繁的网络通信，性能的短板是非常突出的。
总之，在高性能、高并发的应用场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用性，因此在并发量不是太高的应用场景中，还是推荐使用ZooKeeper的分布式锁。
目前分布式锁，比较成熟、主流的方案有两种：
（1）基于Redis的分布式锁。适用于并发量很大、性能要求很高而可靠性问题可以通过其他方案去弥补的场景。
（2）基于ZooKeeper的分布式锁。适用于高可靠（高可用），而并发量不是太高的场景。

所以，这里没有谁好谁坏的问题，而是谁更合适的问题        
        
        
+ 1, 首先zookeeper中我们可以创建一个/distributed_lock持久化节点
+ 2, 然后再在/distributed_lock节点下创建自己的临时顺序节点，比如：/distributed_lock/task_00000000008
+ 3, 获取所有的/distributed_lock下的所有子节点，并排序
+ 4, 判读自己创建的节点是否最小值（第一位）
+ 5, 如果是，则获取得到锁，执行自己的业务逻辑，最后删除这个临时节点。
+ 6, 如果不是最小值，则需要监听自己创建节点前一位节点的数据变化，并阻塞。
+ 7, 当前一位节点被删除时，我们需要通过递归来判断自己创建的节点是否在是最小的，如果是则执行5）；如果不是则执行6）（就是递归循环的判断）     
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    