##### 设计原则
###### 1 OPEN-CLOSED principle(OCP, 开闭原则)
        一个软件实体(类,模块,方法等), 应该对扩展开放, 对修改关闭
###### 2 Dependence Inversion principle(DIP, 依赖倒置)
    设计结构时, 高层模块不应该依赖低层模块, 二者应该依赖其抽象

###### 3 Simple Responsibility Principle(SRP, 单一职责原则)
        不要存在多于一个倒置类变更的原因
###### 4 Interface Segregation Principle( ISP,接口隔离)
    用多个专门的接口, 而不使用单一的总接口, 客户端不应该依赖它:
    + 一个类对另一个类的调用应该建立在最最小的的几口之上
    + 建立单一接口, 不用建立庞大臃肿的接口
    + 尽量细化接口, 接口中的方法尽可能少
##### 5 Law of Demeter(迪米特)最少知道原则

###### 6 里氏替换原则（Liskov Substitution Principle，LSP）
里氏替换原则（Liskov Substitution Principle，LSP）是指如果对每一个类型为T1的对象o1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。
这个定义看上去还是比较抽象的，我们重新理解一下。可以理解为一个软件实体如果适用于一个父类，那么一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，引申含义为：子类可以扩展父类的功能，但不能改变父类原有的功能。

    + （1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
    + （2）子类可以增加自己特有的方法。
    + （3）当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
    + （4）当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样

###### 7 合成复用原则（Composite/Aggregate Reuse Principle，CARP）
  合成复用原则（Composite/Aggregate Reuse Principle，CARP）是指尽量使用对象组合（has-a）/聚合（contanis-a）而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。
继承叫作白箱复用，相当于把所有的实现细节暴露给子类。

##### 4 Singleton
   单例对象的类必须保证只有一个实例存在.
 场景:
    1.需要频繁实例化然后销毁的对象。 
    2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 
    3.有状态的工具类对象。 
    4.频繁访问数据库或文件的对象。

+ Hungry(饿汉模式) -- Singleton1
+ Lazy(懒汉模式) -- Singleton2
+ Double Checked Locking(双重检查) -- Singleton3
+ Static Inner Class(静态内部类) --Singleton4
+ Enum(枚举)       -- Singleton5

漏洞修复:　 -- Singleton6
＋　反射调用：　构造方法中判断抛出异常．
＋　序列化和反序列化获取实例：　重写ReadResolve()方法.


























